//
// This file is part of AtomVM.
//
// Copyright 2026 Paul Guyot <pguyot@kallisys.net>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
//

using "platforms/cpus/stm32l552.repl"

sram1:
    size: 0x40000

flash:
    size: 0x80000

// RCC Python peripheral to handle clock configuration.
// The base stm32l552.repl uses static Tags for RCC_CR and RCC_CFGR which
// don't support clock switching (SWS never changes), causing
// HAL_RCC_ClockConfig to hang.
//
// L5 RCC register layout:
//   CR (0x00):   MSION[0], MSIRDY[1], HSION[8], HSIRDY[10],
//                HSEON[16], HSERDY[17], PLLON[24], PLLRDY[25],
//                PLLSAI1ON[26], PLLSAI1RDY[27], PLLSAI2ON[28], PLLSAI2RDY[29]
//   CFGR (0x08): SW[1:0], SWS[3:2]
rcc: Python.PythonPeripheral @ sysbus 0x40021000
    size: 0x400
    initable: true
    script: '''
if request.IsInit:
    regs = {0x0: 0x63}

if request.IsWrite:
    regs[request.Offset] = request.Value
    if request.Offset == 0x8:
        sw = request.Value & 0x3
        regs[0x8] = (request.Value & ~0xC) | (sw << 2)
elif request.IsRead:
    if request.Offset == 0x0:
        cr = regs.get(0x0, 0x63)
        msion = cr & 0x1
        hsion = (cr >> 8) & 0x1
        hseon = (cr >> 16) & 0x1
        pllon = (cr >> 24) & 0x1
        pllsai1on = (cr >> 26) & 0x1
        pllsai2on = (cr >> 28) & 0x1
        cr &= ~((1 << 1) | (1 << 10) | (1 << 17) | (1 << 25) | (1 << 27) | (1 << 29))
        request.Value = cr | (msion << 1) | (hsion << 10) | (hseon << 17) | (pllon << 25) | (pllsai1on << 27) | (pllsai2on << 29)
    else:
        request.Value = regs.get(request.Offset, 0)
'''

// PWR Python peripheral for voltage scaling.
// Stores writes and returns them on read.
// CR1 (offset 0x00): VOS[10:9] defaults to Range 1 (0x200).
// SR1 (offset 0x10): SMPSHPRDY (bit 15) always set = SMPS high-power ready.
// SR2 (offset 0x14): VOSF (bit 10) always clear = scaling complete.
pwr: Python.PythonPeripheral @ sysbus 0x40007000
    size: 0x400
    initable: true
    script: '''
if request.IsInit:
    regs = {0x0: 0x200}

if request.IsWrite:
    regs[request.Offset] = request.Value
elif request.IsRead:
    request.Value = regs.get(request.Offset, 0)
    if request.Offset == 0x10:
        request.Value |= (1 << 15)
    elif request.Offset == 0x14:
        request.Value &= ~(1 << 10)
'''

// Flash controller for FLASH_ACR (latency, prefetch, cache enable).
// HAL_RCC_ClockConfig reads back FLASH_ACR to verify latency was applied.
flash_ctrl: MTD.STM32F4_FlashController @ sysbus 0x40022000
    flash: flash

// ICACHE peripheral stub.
// HAL_ICACHE_Invalidate polls SR (offset 0x04) for BSYENDF (bit 1) = 1
// and BUSYF (bit 0) = 0.
icache: Python.PythonPeripheral @ sysbus 0x40030400
    size: 0x400
    initable: true
    script: '''
if request.IsInit:
    regs = {}

if request.IsWrite:
    regs[request.Offset] = request.Value
elif request.IsRead:
    request.Value = regs.get(request.Offset, 0)
    if request.Offset == 0x04:
        request.Value = (request.Value | 0x2) & ~0x1
'''
